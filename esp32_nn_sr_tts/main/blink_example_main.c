#include <stdio.h>
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "driver/gpio.h"
#include "esp_log.h"

#include "sdkconfig.h"
#include "freertos/FreeRTOS.h"
#include "freertos/queue.h"
#include "freertos/semphr.h"
//#include "esp_audio.h"

#include "esp_system.h"

#include "esp_log.h"
#include "esp_mac.h"
#include "nvs_flash.h"
#include "sys/socket.h"
#include "lwip/err.h"
#include "lwip/sys.h"
#include "netdb.h"
#include "arpa/inet.h"
#include "I2Sto.h"
#include <string.h>
#include "esp_log.h"
#include "driver/i2s.h"
//#include "driver/i2s_std.h"
#include "esp_mn_speech_commands.h"
#include <math.h>

#include "driver/uart.h"



#include "esp_mn_models.h"
#include "model_path.h"
#include "esp_mn_iface.h"
#include "esp_wn_iface.h"
#include "esp_wn_models.h"
#include "esp_afe_sr_models.h"
#include "esp_afe_sr_iface.h"

#include <stdio.h>

#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "driver/i2c.h"
#include "esp_err.h"
#include "esp_log.h"

#include "esp_tts.h"
#include "esp_partition.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "esp_system.h"
#include "esp_tts.h"
#include "esp_tts_voice_xiaole.h"
#include "esp_tts_voice_template.h"
#include "esp_tts_player.h"
#include "esp_board_init.h"

#include "wav_encoder.h"
#include "esp_partition.h"
#include "esp_idf_version.h"

#include <sys/unistd.h>
#include <sys/stat.h>
#include "esp_vfs_fat.h"
#include "esp_spiffs.h"

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "esp_system.h"
#include "esp_tts.h"
#include "esp_tts_voice_xiaole.h"
#include "esp_tts_voice_template.h"
#include "esp_tts_player.h"
#include "esp_board_init.h"
#include "ringbuf.h"



#include "wav_encoder.h"
#include "esp_partition.h"
#include "esp_idf_version.h"

#include <stdint.h>
#include "driver/i2s.h"
#include "driver/gpio.h"
#include "esp_check.h"

static i2s_chan_handle_t tx_chan;        // I2S tx channel handler
static i2s_chan_handle_t rx_chan;        // I2S tx channel handler

#define UART_PORT_NUM      UART_NUM_1
#define UART_TX_PIN        GPIO_NUM_38  // 接主控板 RX
#define UART_RX_PIN        GPIO_NUM_39  // 接主控板 TX
#define UART_BUF_SIZE      1024
#define BAUD_RATE          115200

#define bufferLen 512
#include <stdio.h>
#include <math.h>
#include <stdint.h>
#include <stdlib.h>
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "driver/i2s_std.h"
#include "driver/gpio.h"
#include "esp_check.h"


// 音频配置
#define SAMPLE_RATE     8000       // 采样率（44.1kHz）
#define SAMPLE_BITS     I2S_BITS_PER_SAMPLE_16BIT // 每样本 16 位
#define DMA_BUF_COUNT   4           // DMA 缓冲区数量
#define DMA_BUF_LEN     1024        // 每个缓冲区的大小
#define EXAMPLE_BUFF_SIZE               2048

void tts(char *prompt1){
    
    const esp_partition_t* part=esp_partition_find_first(ESP_PARTITION_TYPE_DATA, ESP_PARTITION_SUBTYPE_ANY, "voice_data");
    if (part==NULL) { 
        printf("Couldn't find voice data partition!\n"); 
        return ;
    } else {
        printf("voice_data paration size:%d\n", part->size);
    }
    void* voicedata;
#if ESP_IDF_VERSION >= ESP_IDF_VERSION_VAL(5, 0, 0)
    esp_partition_mmap_handle_t mmap;
    esp_err_t err=esp_partition_mmap(part, 0, part->size, ESP_PARTITION_MMAP_DATA, (const void**)&voicedata, &mmap);
#else
    spi_flash_mmap_handle_t mmap;
    esp_err_t err=esp_partition_mmap(part, 0, part->size, SPI_FLASH_MMAP_DATA, &voicedata, &mmap);
#endif
    if (err != ESP_OK) {
        printf("Couldn't map voice data partition!\n"); 
        return ;
    }
    esp_tts_voice_t *voice=esp_tts_voice_set_init(&esp_tts_voice_template, (int16_t*)voicedata); 
    
    esp_tts_handle_t *tts_handle=esp_tts_create(voice);

    /*** 2. play prompt text ***/
    //char *prompt1="欢迎来到华南理工大学欢迎来到华南理工大学欢迎来到华南理工大学欢迎来到华南理工大学";  
    printf("%s\n", prompt1);

    if (esp_tts_parse_chinese(tts_handle, prompt1)) {
            int len[1]={0};
            size_t w_bytes = 0;
            do {
                short *pcm_data=esp_tts_stream_play(tts_handle, len, 2);

                //i2s_channel_write(tx_chan, pcm_data, len[0] * 2, &w_bytes, portMAX_DELAY);
                i2s_write(I2S_NUM_1,pcm_data, len[0]*2,&w_bytes, portMAX_DELAY);
                //printf("pcm_data: %p\n", (void *)pcm_data);
                //printf("data:%d \n", len[0]);
            } while(len[0]>0);
            //i2s_zero_dma_buffer(0);
    }
    esp_tts_stream_reset(tts_handle);
    //ESP_ERROR_CHECK(i2s_channel_disable(tx_chan));


}
// void Init_i2s_new_0(void)
// {
//     /* Setp 1: Determine the I2S channel configuration and allocate both channels
//      * The default configuration can be generated by the helper macro,
//      * it only requires the I2S controller id and I2S role */
//     printf("I2S_NUM_AUTO = %d\n", I2S_NUM_0);
//     i2s_chan_config_t chan_cfg = I2S_CHANNEL_DEFAULT_CONFIG(I2S_NUM_0, I2S_ROLE_MASTER);
//     ESP_ERROR_CHECK(i2s_new_channel(&chan_cfg, NULL, &rx_chan));

//     /* 步骤 2: 设置标准模式的配置，并初始化接收和发送通道
//      * 插槽配置和时钟配置可以通过宏生成
//      * 这些两个辅助宏定义在 'i2s_std.h' 中，仅可用于标准模式。
//      * 它们可以帮助指定初始化或重新配置的插槽和时钟配置 */
//     i2s_std_config_t std_cfg = {
//         .clk_cfg = I2S_STD_CLK_DEFAULT_CONFIG(16000),
//         .slot_cfg = I2S_STD_PHILIPS_SLOT_DEFAULT_CONFIG(I2S_DATA_BIT_WIDTH_32BIT, I2S_SLOT_MODE_MONO),
//         .gpio_cfg =
//             {
//                 .mclk = I2S_GPIO_UNUSED, // some codecs may require mclk signal, this example doesn't need it
//                 .bclk = 5,
//                 .ws = 4,
//                 .dout = I2S_GPIO_UNUSED,
//                 .din = 6, // 在双工模式下，将输出和输入绑定到同一个 GPIO 可以实现环回
//                 // internally
//                 .invert_flags =
//                     {
//                         .mclk_inv = false,
//                         .bclk_inv = false,
//                         .ws_inv = false,
//                     },
//             },
//     };
//     /* 初始化通道 */
//     // ESP_ERROR_CHECK(i2s_channel_init_std_mode(tx_chan, &std_cfg));
//     /* 默认情况下在单声道模式下仅接收左声道，
//      * 在此处更新为右声道，以演示如何更改默认配置 */
//     //std_cfg.slot_cfg.slot_mask = I2S_STD_SLOT_LEFT;
//     ESP_ERROR_CHECK(i2s_channel_init_std_mode(rx_chan, &std_cfg));

//     ESP_ERROR_CHECK(i2s_channel_enable(rx_chan));
// }

// void Init_i2s_new_1(void) {
//     printf("I2S_NUM_AUTO = %d\n", I2S_NUM_1);
//     i2s_chan_config_t tx_chan_cfg = I2S_CHANNEL_DEFAULT_CONFIG(I2S_NUM_1, I2S_ROLE_MASTER);
//     ESP_ERROR_CHECK(i2s_new_channel(&tx_chan_cfg, &tx_chan, NULL));


//     i2s_std_config_t tx_std_cfg = {
//             .clk_cfg  = I2S_STD_CLK_DEFAULT_CONFIG(44100),
//             .slot_cfg = I2S_STD_MSB_SLOT_DEFAULT_CONFIG(I2S_DATA_BIT_WIDTH_32BIT,
//                                                         I2S_SLOT_MODE_MONO),

//             .gpio_cfg = {
//                     .mclk = I2S_GPIO_UNUSED,    // some codecs may require mclk signal, this example doesn't need it
//                     .bclk = 15,
//                     .ws   = 16,
//                     .dout = 7,
//                     .din  = -1,
//                     .invert_flags = {
//                             .mclk_inv = false,
//                             .bclk_inv = false,
//                             .ws_inv   = false,
//                     },
//             },
//     };
//     ESP_ERROR_CHECK(i2s_channel_init_std_mode(tx_chan, &tx_std_cfg));

//     ESP_ERROR_CHECK(i2s_channel_enable(tx_chan));
// }


static const char *TAG = "UART_VOICE";

void uart_init()
{
    uart_config_t uart_config = {
        .baud_rate = BAUD_RATE,
        .data_bits = UART_DATA_8_BITS,
        .parity    = UART_PARITY_DISABLE,
        .stop_bits = UART_STOP_BITS_1,
        .flow_ctrl = UART_HW_FLOWCTRL_DISABLE
    };

    ESP_ERROR_CHECK(uart_driver_install(UART_PORT_NUM, UART_BUF_SIZE * 2, 0, 0, NULL, 0));
    ESP_ERROR_CHECK(uart_param_config(UART_PORT_NUM, &uart_config));
    ESP_ERROR_CHECK(uart_set_pin(UART_PORT_NUM, UART_TX_PIN, UART_RX_PIN, UART_PIN_NO_CHANGE, UART_PIN_NO_CHANGE));
}

void send_command(const char *cmd)
{
    uart_write_bytes(UART_PORT_NUM, cmd, strlen(cmd));
    ESP_LOGI(TAG, "发送命令: %s", cmd);
}

// void receive_response_task(void *arg)
// {
//     uint8_t data[128];
//     while (1) {
//         int len = uart_read_bytes(UART_PORT_NUM, data, sizeof(data) - 1, pdMS_TO_TICKS(1000));
//         if (len > 0) {
//             data[len] = '\0';
//             ESP_LOGI(TAG, "收到主控回复：%s", data);
//         }
//     }
// }

#define TAG "app"
typedef struct {
    wakenet_state_t     wakenet_mode;
    esp_mn_state_t      state;
    int                 command_id;
} sr_result_t;

static QueueHandle_t            g_result_que    = NULL;
int detect_flag = 0;
static esp_afe_sr_iface_t *afe_handle = NULL;
static volatile int task_flag = 0;
static model_iface_data_t       *model_data     = NULL;
static const esp_mn_iface_t     *multinet       = NULL;
//命令词
const char *cmd_phoneme[7] = {
    "mo zhang qi dong",//开机
    "da kai lan ya", //蓝牙
    "da kai hong wai",//红外
    "da kai wang luo",//wifi
    "guan ji",//关机
    //"bo fang yin yue",//播放音乐
    "zi mo shi ling",
    "zi mo shi yi"
};

void feed_Task(void *arg)
{
    esp_afe_sr_data_t *afe_data = arg;

    int feed_chunksize = afe_handle->get_feed_chunksize(afe_data);
    int feed_nch = afe_handle->get_feed_channel_num(afe_data);
    // assert(feed_nch<feed_channel);
    int16_t *feed_buff = (int16_t *) malloc(feed_chunksize * feed_nch * sizeof(int16_t));
            

    assert(feed_buff);
    while (task_flag) {
        size_t bytesIn = 0;
        esp_err_t result = i2s_read(I2S_NUM_0, feed_buff, feed_chunksize * feed_nch * sizeof(int16_t), &bytesIn, portMAX_DELAY);
        //esp_err_t result = i2s_channel_read(rx_chan, feed_buff, feed_chunksize * feed_nch * sizeof(int16_t), &bytesIn, portMAX_DELAY);
        afe_handle->feed(afe_data, feed_buff);
        //vTaskDelay(pdMS_TO_TICKS(100));
    }
    if (feed_buff) {
        free(feed_buff);
        feed_buff = NULL;
        printf("feed_buff freed");
    }
    vTaskDelete(NULL);
}

/* 产生一个字符串列表 */
static const char *wakeup[4] = {
    "我在这里",
    "你好呀",
    "喜欢您来",
    "我是小爱同学",
    "你叫我吗"
};

void detect_Task(void *arg)
{
    esp_afe_sr_data_t *afe_data = arg;
    int afe_chunksize = afe_handle->get_fetch_chunksize(afe_data);
    int16_t *buff = malloc(afe_chunksize * sizeof(int16_t));
    assert(buff);
    printf("------------detect start------------\n");

    while (task_flag) {
        afe_fetch_result_t* res = afe_handle->fetch(afe_data); 

        if (!res || res->ret_value == ESP_FAIL) {
            printf("fetch error!\n");
            break;
        }

        if (res->wakeup_state == WAKENET_DETECTED) {  // 得到唤醒词
            printf("-----------DETECTED-----------\n");
             uint32_t rand_num = esp_random() % 5;
             tts(wakeup[rand_num]);
           
            //printf("model index:%d, word index:%d\n", res->wakenet_model_index, res->wake_word_index);
            printf("-----------LISTENING COMMAND-----------\n");

            // 产生一个 0 到 4 的随机整数
           
            //printf("Generated random number: %u\n", rand_num);

            sr_result_t result = {
                .wakenet_mode = WAKENET_DETECTED,
                .state       = ESP_MN_STATE_DETECTING,
                .command_id  = rand_num,
            };
            xQueueSend(g_result_que, &result, 10);
            detect_flag = true;
        
        } else if (res->wakeup_state == WAKENET_CHANNEL_VERIFIED) {
            detect_flag = true;
            afe_handle->disable_wakenet(afe_data);
        }
        if (true == detect_flag) {
            esp_mn_state_t mn_state = ESP_MN_STATE_DETECTING;

            mn_state = multinet->detect(model_data, res->data);

            if (ESP_MN_STATE_DETECTING == mn_state) {
                continue;
            }

            if (ESP_MN_STATE_TIMEOUT == mn_state) {//超时
                ESP_LOGW(TAG, "Time out");
                sr_result_t result = {
                    .wakenet_mode = WAKENET_NO_DETECT,
                    .state = mn_state,
                    .command_id = 0,
                };
                xQueueSend(g_result_que, &result, 10);
                afe_handle->enable_wakenet(afe_data);
                detect_flag = false;
                continue;
            }

            if (ESP_MN_STATE_DETECTED == mn_state) {//得到指令
                esp_mn_results_t *mn_result = multinet->get_results(model_data);
                for (int i = 0; i < mn_result->num; i++) {
                    ESP_LOGI(TAG, "TOP %d, command_id: %d, phrase_id: %d, prob: %f",
                            i + 1, mn_result->command_id[i], mn_result->phrase_id[i], mn_result->prob[i]);
                }

                int sr_command_id = mn_result->command_id[0];
                ESP_LOGI(TAG, "Deteted command : %d", sr_command_id);
                sr_result_t result = {
                    .wakenet_mode = WAKENET_NO_DETECT,
                    .state = mn_state,
                    .command_id = sr_command_id,
                };
                xQueueSend(g_result_que, &result, 10);
            }
        }
        // vTaskDelay(pdMS_TO_TICKS(100));
    }
    if (buff) {
        free(buff);
        buff = NULL;
    }
    vTaskDelete(NULL);
}

void sr_handler_task(void *pvParam)
{
    QueueHandle_t xQueue = (QueueHandle_t) pvParam;

    while (true) {
        sr_result_t result;
        xQueueReceive(xQueue, &result, portMAX_DELAY);

        ESP_LOGI(TAG, "cmd:%d, wakemode:%d,state:%d", result.command_id, result.wakenet_mode, result.state);

        if (ESP_MN_STATE_TIMEOUT == result.state) {
            ESP_LOGI(TAG, "timeout");

            continue;
        }

        if (WAKENET_DETECTED == result.wakenet_mode) {
            ESP_LOGI(TAG, "wakenet detected");
            //send_command("$MODE:1#");  // 模拟语音指令
            printf("%d",result.command_id);
            continue;
        }
        switch (result.command_id) {
                case 0:
                result.command_id = 99;
                    tts("你好我是魔杖请对我下达指令");
                    
                    break;
                case 1:
                send_command("$MainMode:BLE#");
                result.command_id = 99;
                    tts("已开启蓝牙键鼠模式");
                    
                    break;
                case 2:
                send_command("$MainMode:IR#");
                result.command_id = 99;
                    tts("已开启红外模式");
                    
                    break;
                case 3:
                send_command("$MainMode:WIFI#");
                result.command_id = 99;
                    tts("已开启无线局域网");
                    
                    break;
                case 4:
                result.command_id = 99;
                    tts("期待下次见面");
                    
                break;
                case 5:
                send_command("$SubMode:SUB_0#");
                result.command_id = 99;
                 tts("已进入零号模式");
                 
                break;
                case 6:
                send_command("$SubMode:SUB_1#");
                 result.command_id = 99;
                 tts("已进入一号模式");
                
                break;
                default:
                    ESP_LOGI(TAG, "未知命令ID: %d", result.command_id);
                    break;
            }
    }
}

int app_main()
{
    /* 初始化NVS */
    esp_err_t ret = nvs_flash_init();
    if (ret == ESP_ERR_NVS_NO_FREE_PAGES || ret == ESP_ERR_NVS_NEW_VERSION_FOUND) {
        ESP_ERROR_CHECK(nvs_flash_erase());
        ESP_ERROR_CHECK(nvs_flash_init());
    }
    uart_init();
    
    Init_i2s_0();
    Init_i2s_1();
   
   //步骤1：初始化AFE配置
    srmodel_list_t *models = esp_srmodel_init("model");
    afe_config_t *afe_config = afe_config_init("M", models, AFE_TYPE_SR, AFE_MODE_LOW_COST);
    //步骤2：创建AFE实例
    afe_config->wakenet_model_name = esp_srmodel_filter(models, ESP_WN_PREFIX, NULL);
    afe_config->aec_init = false;
    afe_handle = esp_afe_handle_from_config(afe_config);
    esp_afe_sr_data_t *afe_data = afe_handle->create_from_config(afe_config);

    char *mn_name = esp_srmodel_filter(models, ESP_MN_CHINESE, NULL);
    if (NULL == mn_name) {
        printf("No multinet model foundaaa");
        return ESP_FAIL;
    }
    multinet = esp_mn_handle_from_name(mn_name);
    model_data = multinet->create(mn_name, 10000);//设置唤醒超时时间
    printf( "load multinet:%s", mn_name);
    esp_mn_commands_clear();//清除唤醒指令
    for (int i = 0; i < sizeof(cmd_phoneme) / sizeof(cmd_phoneme[0]); i++) {
        esp_mn_commands_add(i, (char *)cmd_phoneme[i]);//逐个将唤醒指令放入
    }
    esp_mn_commands_update();//更新命令词列表
    esp_mn_commands_print();
    multinet->print_active_speech_commands(model_data);//输出目前激活的命令词
    afe_config_free(afe_config);

    task_flag = 1;
    // wifi_init_sta();
    g_result_que = xQueueCreate(1, sizeof(sr_result_t));
    //tts();

    xTaskCreatePinnedToCore(&feed_Task, "feed", 8 * 1024, (void*)afe_data, 5, NULL, 0);
    xTaskCreatePinnedToCore(&detect_Task, "detect", 4 * 1024, (void*)afe_data, 5, NULL, 1);
    xTaskCreatePinnedToCore(&sr_handler_task, "SR Handler Task", 4 * 1024, g_result_que, 1, NULL, 1);
    //TaskCreate(receive_response_task, "uart_recv", 2048, NULL, 10, NULL);

return 0;
}






